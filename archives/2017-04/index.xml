<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>2017 04 on 听风流水的博客</title>
    <link>https://luyuekai.github.io/archives/2017-04/index.xml</link>
    <description>Recent content in 2017 04 on 听风流水的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://luyuekai.github.io/archives/2017-04/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>effective java 读书笔记（四）</title>
      <link>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B/</link>
      <pubDate>Sun, 30 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;四二. 慎用可变参数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;四三. 返回零长度的数组或者集合，而不是null&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四四. 为所有导出的API元素编写文档注释&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为了正确地编写API文档，必须在每个被导出的类，接口，构造器，方法和域声明之前增加一个文档注释&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法的文档注释应该简洁地描述出它和客户端之间的约定。&lt;/p&gt;

&lt;h3 id=&#34;第八章-通用程序设计&#34;&gt;第八章  通用程序设计&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四五. 将局部变量的作用域最小化&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要使局部变量的作用最小化，最有力的方法就是在第一次使用它的地方声明。&lt;/li&gt;
&lt;li&gt;几乎每个局部变量的声明都应该包含一个初始化表达式。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四六 for-each循环优先于传统的for循环&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对两个集合进行嵌套迭代时常犯的错误如下：&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tets0426 {
     enum Suit {CLUB, DIAMOND, HEART , SPADE}
     enum Rank {ACE,DEUCE, THREE,FOUR,FIVE,SIX,SEVEN,EIGHT,NINE,TEN,JACK,QUEEN,KING}
     static  class Card{
          public  Card(Suit suit,Rank rank){

          }

      }

    public static void main(String[] args) {



        Collection&amp;lt;Suit&amp;gt; suits = Arrays.asList(Suit.values());
        Collection&amp;lt;Rank&amp;gt; ranks = Arrays.asList(Rank.values());

        List&amp;lt;Card&amp;gt; deck = new ArrayList&amp;lt;&amp;gt;();

        for (Iterator&amp;lt;Suit&amp;gt; i =  suits.iterator(); i.hasNext();) {
            for (Iterator&amp;lt;Rank&amp;gt; j =  ranks.iterator(); j.hasNext();) {
                Suit s1 = i.next();
                Rank r1 = j.next();
                deck.add(new Card(s1,r1));
                System.out.println(s1+&amp;quot; &amp;quot;+r1);
            }
        }

    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;上述代码问题在于，在迭代器上对外部的集合（suits）调用了太多次next方法。我们应该从外部的循环进行调用，以便每种花色调用一次，但它却是从内部循环调用，因此它是每张牌调用一次。在用完所有花色之后，循环就会抛出&lt;code&gt;NoSuchElementException&lt;/code&gt;异常。&lt;/li&gt;
&lt;li&gt;如果不幸，外部集合的大小是内部集合大小的几倍&amp;mdash;-可能因为它们是相同的集合&amp;mdash;-循环就会终止，但是不会完成你想要的工作。例如，下面是个考虑不周的尝试，&lt;strong&gt;要打印一对骰子的所有可能的滚法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestItrator {

    enum Face {

        ONE, TWO , THREE, FOUR, FIVE, SIX
    }

    public static void main(String[] args) {
        Collection&amp;lt;Face&amp;gt; faces = Arrays.asList(Face.values());

        for (Iterator iterator = faces.iterator(); iterator.hasNext();) {
//             Face f = (Face) iterator.next();
            for (Iterator iterator1 = faces.iterator(); iterator1.hasNext();) {

//                  System.out.println(f + &amp;quot; &amp;quot; + iterator1.next());
                System.out.println(iterator.next() + &amp;quot; &amp;quot; + iterator1.next());
            }

        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ONE ONE
TWO TWO
THREE THREE
FOUR FOUR
FIVE FIVE
SIX SIX
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class TestItrator {

    enum Face {

        ONE, TWO , THREE, FOUR, FIVE, SIX
    }

    public static void main(String[] args) {
        Collection&amp;lt;Face&amp;gt; faces = Arrays.asList(Face.values());

        for (Iterator iterator = faces.iterator(); iterator.hasNext();) {
             Face f = (Face) iterator.next();
            for (Iterator iterator1 = faces.iterator(); iterator1.hasNext();) {

                  System.out.println(f + &amp;quot; &amp;quot; + iterator1.next());
//                System.out.println(iterator.next() + &amp;quot; &amp;quot; + iterator1.next());
            }

        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的打印结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ONE ONE
ONE TWO
ONE THREE
ONE FOUR
ONE FIVE
ONE SIX
TWO ONE
.......
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>effective java 读书笔记（三）</title>
      <link>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/</link>
      <pubDate>Sat, 29 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;第五章-泛型&#34;&gt;第五章 泛型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;二三 请不要在新代码中使用原生态类型&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;泛型信息可以在运行时被擦除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二四. 消除非受验警告&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二五. 列表优先于数组&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二六. 优先考虑泛型&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二七. 优先考虑泛型方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二八. 利用有限制通配符来提升API的灵活性&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;PECS规则： producer-extends,consumer-super (PECS)&lt;/li&gt;
&lt;li&gt;所有的comparable 和 comparator 都是消费者&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二九. 优先考虑类型安全的异构容器&lt;/p&gt;

&lt;h3 id=&#34;第六章-枚举和注解&#34;&gt;第六章 枚举和注解&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三十. 用enum代替 int 常量&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三一. 用实例域代替序数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三二. 用EnumSet代替位域（不看，用到了再说）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三三. 用EnumMap代替序数索引（同上）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三四. 用接口模拟可伸缩的枚举&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型，对它进行模拟。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三五. 注解优先于命名模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三六. 坚持使用Override注解&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三七. 用标记接口定义类型&lt;/p&gt;

&lt;h3 id=&#34;第七章-方法&#34;&gt;第七章 方法&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三八. 检查参数的有效性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三九. 必要时进行保护性拷贝&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四十. 谨慎设计方法签名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;谨慎的选择方法的名称&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;不要过于追求提供便利的方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;避免过长的参数列表。 目标是四个参数，或者更少。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四一. 慎用重载（overload）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要调用哪个重载（overloading）方法是在编译时做出决定的&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CollectionClassifier{
public static String classify(Set&amp;lt;?&amp;gt; s){
return &amp;quot;Set&amp;quot;;
}
public static String classify(List&amp;lt;?&amp;gt; lst){
return &amp;quot;List&amp;quot;;
}
public static String classify(Collection&amp;lt;?&amp;gt; c){
return &amp;quot;Unknow Collection&amp;quot;;
}
public static void main(String args){
Collection&amp;lt;?&amp;gt;[] collections = {
new HashSet&amp;lt;String&amp;gt;(),
new ArrayList&amp;lt;BigInteger&amp;gt;(),
new HashMap&amp;lt;String,String&amp;gt;().values()
};
for (Collection&amp;lt;?&amp;gt; c : collections){
System.out.println(classify(c));
}
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于上述代码，我们期望打印出来的结果为&lt;code&gt;Set,List,Unknow Collection&lt;/code&gt;,然而结果却并不如意。实际打印出来的是三个&lt;code&gt;Unknow Collection&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也就是说&lt;strong&gt;对于重载方法（overload）是在编译时刻决定的，对于被覆写的方法（override），是在运行时刻决定的&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以下是一个现在仍存在的问题（主要由ArrayList集合类的remove方法重载导致）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public class SetList {
    public static void main(String[] args) {
        Set&amp;lt;Integer&amp;gt; set = new TreeSet&amp;lt;Integer&amp;gt;();
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();

        for (int i = -3; i &amp;lt; 3; i++) {
            set.add(i);
            list.add(i);
        }
        for (int i = 0; i &amp;lt; 3; i++) {
            set.remove(i);
            list.remove(i);
        }
        System.out.println(set+&amp;quot; &amp;quot;+ list);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;[-3, -2, -1] [-2, 0, 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Set的输出结果如同我们想的一样，但是List的结果不一样。实际发生的情况是：set.remove(E),选择重载方法的参数实际上是Integer，这里进行了自动装箱，把int装箱成了Integer；对于List，有两个重载函数，这里直接重载了list.remove(i)，并没有重载到list.remove(E)，是从list的指定位置进行remove，所以先移除了第0个，也就是-3，list中所有元素前移；再移除第1个，也就是list中当前第2个，也就是-1；以此类推，最后得到-2,0,2。我们可以在源码中看到：
来源： &lt;a href=&#34;http://blog.csdn.net/a921122/article/details/54834858&#34;&gt;http://blog.csdn.net/a921122/article/details/54834858&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里List方法调用的是 remove（int ）而不是 remove（Object）查看两者的源码：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;remove(int )&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public E remove(int index) {  
rangeCheck(index);  

modCount++;  
E oldValue = elementData(index);  

int numMoved = size - index - 1;  
if (numMoved &amp;gt; 0)  
    System.arraycopy(elementData, index+1, elementData, index,  
                     numMoved);  
elementData[--size] = null; // clear to let GC do its work  

return oldValue;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在每次移除index位置上的元素后，会将list前移。 过程为，第一次移除0号元素&lt;code&gt;-3&lt;/code&gt;，返回新的list&lt;code&gt;-2,-1,0,1,2&lt;/code&gt;;第二次移除1号元素&lt;code&gt;-1&lt;/code&gt;，返回&lt;code&gt;-2,0,1,2&lt;/code&gt;依次往下进行，最后得到上述出乎意料的答案。&lt;br /&gt;
改进方法：&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;list.remove(Integer)i);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;list.remove(Integer.valueOf(i))&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即可得到正确返回值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>effective java 读书笔记（二）</title>
      <link>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;第三章-对于所有对象都通用的方法&#34;&gt;第三章  对于所有对象都通用的方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;八.  覆盖equals时请遵守通用约定&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;equals方法实现的等价关系: &lt;strong&gt;自反性,对称性,传递性,一致性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;九．覆盖equals时总要覆盖hashCode&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;相等的对象必须具有相等的散列码(hashcode)&lt;/li&gt;
&lt;li&gt;不等的对象散列码可能相等,但最佳实践是&amp;rdquo;为不相等的对象产生不相等的散列码&amp;rdquo;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十. 始终要覆盖toString方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;十一. 谨慎地覆盖clone&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;十二. 考虑实现Comparable接口&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;如果在编写一个值类,具有非常明显的内在排序关系,如按照字母排序,按数值排序,按年代排序,那应该坚决考虑实现Comparable接口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;  public interface Comparable&amp;lt;T&amp;gt;{
  int compareTo(T t)
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;第四章-类和接口&#34;&gt;第四章 类和接口&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;十三. 使类和成员的可访问性最小化&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;尽可能地使每个类或者成员不对外接访问&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类具有公有的静态final数组域,或者返回这种域的访问方法,这几乎总是错误的.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十四. 在公有类中使用访问方法而非公有域&lt;br /&gt;
&lt;code&gt;java
class Point {
public double x;
public double y;
}
&lt;/code&gt;&lt;br /&gt;
正确做法应该设置为private方法,提供setter和getter方法.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;十五. 使可变性最小化&lt;br /&gt;
为了使类成为不可变,应遵循以下五条规则&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;1. 不要提供任何会修改对象状态的方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2. 保证类不会被扩展.一般做法是使这个类成为final&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3. 使所有的域都是final的&lt;/li&gt;
&lt;li&gt;4. 使所有的域都变成私有的&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;5.确保对于任何可变组件的互斥访问&lt;/li&gt;
&lt;li&gt;不可变对象本质上是线程安全的，它们不要求同步&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十六. 复合优先于继承&lt;/li&gt;
&lt;li&gt;十七.  要么为继承而设计，并提供文档说明，要么就禁止继承&lt;br /&gt;
有两种方法可以禁止子类化：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;较容易的：把该类声明为final&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;把所有的构造器都变成私有的，或者包级私有的，并增加一些公有的静态工厂来替代构造器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十八. 接口优于抽象类&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;十九. 接口只用于定义类型&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;二十.  类层次优于标签类&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;标签类过于冗长，容易出错，并且效率低下。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二一. 用函数对象表示策略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;具体的策略类往往使用匿名类声明，下面的语句根据长度对一个字符串数组进行排序：&lt;br /&gt;&lt;/li&gt;

&lt;li&gt;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Arrays.sort(stringArray,new Comparator&amp;lt;String&amp;gt;(){
public int compare(String s1,String s2){
   return  s1.length() - s2.length();
}  
}
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意，采用上述方式使用匿名类时，将会在每次执行调用的时候创建一个新的实例。如果它被重复执行，考虑将函数对象存储到一个私有的静态final域里，并重用它。这样做的另一种好处是，可以为这个函数对象取一个有意义的域名城。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二二. 优先考虑静态成员类&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;嵌套类是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类提供服务。嵌套类有四种：&lt;strong&gt;静态成员类&lt;/strong&gt;、&lt;strong&gt;非静态成员类&lt;/strong&gt;、&lt;strong&gt;匿名类&lt;/strong&gt;、&lt;strong&gt;局部类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>NAT地址转换协议小记</title>
      <link>https://luyuekai.github.io/2017/04/nat%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/nat%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
参考文章：&lt;br /&gt;
1. &lt;a href=&#34;http://www.jianshu.com/p/62028875d53e&#34;&gt;http://www.jianshu.com/p/62028875d53e&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&#34;http://www.cnblogs.com/gaojing/archive/2009/10/09/1579455.html&#34;&gt;http://www.cnblogs.com/gaojing/archive/2009/10/09/1579455.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nat-network-address-translation-地址转换协议&#34;&gt;NAT : Network Address Translation 地址转换协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用场景： 使内网电脑可以访问外网资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优点：

&lt;ul&gt;
&lt;li&gt;用于实现私有网络访问公共网络的功能。&lt;/li&gt;
&lt;li&gt;使用少量的公网IP地址代表较多的私网IP地址，有助于减缓可用IP地址空间的枯竭。&lt;/li&gt;
&lt;li&gt;避免来自网络外部的攻击，隐藏并保护网络内部的计算机&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NAT简介：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;借助于NAT，私有(保留)地址的&amp;rdquo;内部&amp;rdquo;网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址(甚至是1个)即可实现私有地址网络内所有计算机与Internet的通信需求。&lt;/li&gt;
&lt;li&gt;NAT将自动修改IP报文的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成（对于ICMP，NAT也自动完成地址转换）。有些应用程序将源IP地址嵌入到IP报文的数据部分中，所以还需要同时对报文进行修改，以匹配IP头中已经修改过的源IP地址。否则，在报文数据都分别嵌入IP地址的应用程序就不能正常工作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;工作原理&#34;&gt;工作原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当一台内网计算机用户连接Internet资源时，该用户的 TCP/IP 协议产生一个 IP 数据包，该数据包包含以下值，这些值位于 IP 和 TCP 或 UDP 标头中：(粗体内容表示受 NAT 影响的项目)：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;目标 IP 地址：Internet 资源 IP 地址&lt;/li&gt;
&lt;li&gt;源 IP 地址：私有 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：Internet 资源 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：源应用程序 TCP 或 UDP 端口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请求源主机或者其它路由器将此 IP 数据包发送给 NAT, 然后由 NAT 将向外发送的数据包的地址解析如下：

&lt;ul&gt;
&lt;li&gt;目标IP地址：Internet 资源 IP 地址&lt;/li&gt;
&lt;li&gt;源IP 地址：ISP 分配的公用地址&lt;/li&gt;
&lt;li&gt;目标端口：Internet 资源 TCP 或 UDP 端口&lt;/li&gt;
&lt;li&gt;源端口：重新映射的源应用程序TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NAT 将重新映射的 IP 数据包发送到 Internet 。响应计算机将向 NAT 返回一个响应。当 NAT 接收到此响应时，该数据包将包含以下地址信息：

&lt;ul&gt;
&lt;li&gt;目标IP 地址：ISP 分配的公用地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源IP地址：Internet 资源 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：重新映射的源应用程序 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：Internet 资源的 TCP 或者 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当 NAT 完成映射和解析地址后，将向 Internet 客户端发送数据包，此数据包包含以下地址信息：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;目标 IP 地址：私有 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源 IP 地址：Internet 资源 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：源应用程序TCP 或者 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：Internet 资源 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;工作模式-三种-优缺点&#34;&gt;工作模式（三种，优缺点）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;NAT使用基于session的转换规则&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP/UDP&lt;/strong&gt; ：私有Host的Ipv4 + port &amp;lt;======&amp;gt; NAT公网的Ipv4 + port&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICMP&lt;/strong&gt; ：私有Host的Ipv4 + sessionID &amp;lt;======&amp;gt; NAT公网的Ipv4 + sessionID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态NAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT1.png&#34; alt=&#34;静态NAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态NAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT2.png&#34; alt=&#34;动态NAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PAT(port address Translation,端口地址转换,也叫端口地址复用)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT3.png&#34; alt=&#34;PAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>