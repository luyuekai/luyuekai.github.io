<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Effective Java on 听风流水的博客</title>
    <link>https://luyuekai.github.io/tags/effective-java/index.xml</link>
    <description>Recent content in Effective Java on 听风流水的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://luyuekai.github.io/tags/effective-java/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>effective java 读书笔记（一）</title>
      <link>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sun, 16 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
读书时有输入亦应该有输出,此篇记录阅读&lt;strong&gt;effective java&lt;/strong&gt;的重点及心得体会.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;第二章-创建和销毁对象&#34;&gt;第二章  创建和销毁对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一 . 考虑用静态工厂方法代替构造器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类可以提供一个公有的静态工厂方法,它只是返回类的实例的静态方法.&lt;/p&gt;

&lt;p&gt;如下所示:来自Boolean(基本类型boolean的包装类)的简单示例.这个方法将boolean基本类型值转换成了一个Boolean对象引用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public static Boolean valueOf(boolean b){

return b ? Boolean.TRUE : Boolean.FALSE;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 优势

- 1. 静态工厂方法与构造器不同的第一大优势在与: 它们有名称.  

- 2. 第二大优势: 不必在每次调用它们的时候都创建一个新对象.

- 3. 第三大优势: 它们可以返回原返回类型的任何子类型的对象.

- 4. 第四大优势: 在创建参数化类型实例时,它们使代码变得更加简洁.  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二. 遇到多个构造器参数时要考虑用构建器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在遇到许多构造器参数的时候,有第二种代替方法,即JavaBeans模式. 在这种模式下,调用一个无参构造器来创建对象,然后调用setter方法来设置每个必要的参数,以及每个相关的可选参数.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缺点: 在构造过程中JavaBean可能处于不一致的状态.类无法仅仅通过检验构造器参数的有效性来保证一致性.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三. 用私有构造器或者枚举类型强化Singleton属性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四. 通过私有构造器强化不可实例化的能力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;五. 避免创建不必要的对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个极端的反面例子&lt;code&gt;String s = new String(&amp;quot;stringette&amp;quot;);&lt;/code&gt;该语句每次执行都会创建一个String实例,但是都是不必要的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;改进版本: &lt;code&gt;String s = &amp;quot;stringette&amp;quot;&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;六. 消除过期的对象引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;七. 避免使用终结方法.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;终结方法的优先级要明显低于其他线程.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不应该依赖终结方法来更新重要的持久状态.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显式的终止方法通常与 try-finally 结构结合起来使用,以确保及时终止.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>