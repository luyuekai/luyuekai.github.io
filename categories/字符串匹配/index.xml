<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>字符串匹配 on 听风流水的博客</title>
    <link>https://luyuekai.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/index.xml</link>
    <description>Recent content in 字符串匹配 on 听风流水的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://luyuekai.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>字符串匹配算法</title>
      <link>https://luyuekai.github.io/2017/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 15 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;
&lt;/p&gt;

&lt;h2 id=&#34;字符串匹配算法&#34;&gt;字符串匹配算法&lt;/h2&gt;

&lt;p&gt;最近在刷leetcode时,运用到了字符串匹配算法.关于字符串匹配算法,之前在查资料时,也做过一些研究,脑海中大概有两种想法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;暴力搜索法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;KMP算法&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面对这两种算法做一下总结: 首先总结简单易懂,并且利用率较高的&lt;code&gt;暴力搜索法&lt;/code&gt;吧!&lt;/p&gt;

&lt;p&gt;先明确两个概念:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String txt: 被查找的文本,需要从中来查找要求的字符串&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String pat (pattern): 目标字符串,不少资料中称之为&lt;code&gt;模式&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法的目的是: 在文本字符串txt中查找模式字符串pat第一次出现的位置.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法思想:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用指针i跟踪文本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用指针j跟踪模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于每个i,代码首先将j重置为0并不断将它增大,直到找到了一个不匹配的字符或者&lt;code&gt;j==pat.length&lt;/code&gt;为止&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在模式字符串结束之前文本字符串就已经结束(&lt;strong&gt;即&lt;/strong&gt;&lt;code&gt;i==txt.length-pat.length+1&lt;/code&gt;&lt;strong&gt;思考这个细节,我在第一次写的时候,直接匹配到了txt的最后一个字符.而这样来写则考虑到了txt剩余字符串的长度,减少了不必要的计算次数&lt;/strong&gt;),那么就没有找到匹配,模式字符串在文本中不存在.约定不存在时返回 txt的长度.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
    public static int search(String pat, String txt) {



        int M = pat.length();

        int N = txt.length();

        for (int i = 0; i &amp;lt;= N - M; i++) {

            int j;

            for (j = 0; j &amp;lt; M; j++) {

                if (txt.charAt(i + j) != pat.charAt(j)) {

                    break;

                }

            }

            if (j == M) {

                return i;

            }

        }

        return N;

    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在典型的字符串处理应用程序中,索引j增长的机会很少,因此该算法的运行时间与N成正比.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;暴力搜索算法的另一种&lt;strong&gt;具有指导意义的实现&lt;/strong&gt;:(显式回退)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;算法思想&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;指针i跟踪文本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针j跟踪模式.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在i和j指向的字符匹配时,代码进行的字符比较和上一个实现相同. 注意,这段代码中的i值相当于上一段代码中的i+j:它指向的是文本中已经匹配过的字符序列的末端(i以前指向的是这个序列的开头)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果i和j指向的字符不匹配了,那么需要回退这两个指针的值:&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将j重新指向模式的开头&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将i 指向本次匹配的开始位置的下一个字符&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
    public static int search2(String pat, String txt) {



        int j, M = pat.length();

        int i, N = txt.length();

        for (i = 0, j = 0; i &amp;lt; N &amp;amp;&amp;amp; j &amp;lt; M; i++) {

            if (txt.charAt(i) == pat.charAt(j)) {

                j++;



            } else {

                i -= j;

                j = 0;

            }

        }

        if (j == M) {

            return i - M;

        } else {

            return N;

        }

    }

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>