<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Reading Notes on 听风流水的博客</title>
    <link>https://luyuekai.github.io/categories/reading-notes/index.xml</link>
    <description>Recent content in Reading Notes on 听风流水的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://luyuekai.github.io/categories/reading-notes/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>NAT地址转换协议小记</title>
      <link>https://luyuekai.github.io/2017/04/nat%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/nat%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
参考文章：&lt;br /&gt;
1. &lt;a href=&#34;http://www.jianshu.com/p/62028875d53e&#34;&gt;http://www.jianshu.com/p/62028875d53e&lt;/a&gt;&lt;br /&gt;
2. &lt;a href=&#34;http://www.cnblogs.com/gaojing/archive/2009/10/09/1579455.html&#34;&gt;http://www.cnblogs.com/gaojing/archive/2009/10/09/1579455.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nat-network-address-translation-地址转换协议&#34;&gt;NAT : Network Address Translation 地址转换协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用场景： 使内网电脑可以访问外网资源&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;优点：

&lt;ul&gt;
&lt;li&gt;用于实现私有网络访问公共网络的功能。&lt;/li&gt;
&lt;li&gt;使用少量的公网IP地址代表较多的私网IP地址，有助于减缓可用IP地址空间的枯竭。&lt;/li&gt;
&lt;li&gt;避免来自网络外部的攻击，隐藏并保护网络内部的计算机&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NAT简介：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;借助于NAT，私有(保留)地址的&amp;rdquo;内部&amp;rdquo;网络通过路由器发送数据包时，私有地址被转换成合法的IP地址，一个局域网只需使用少量IP地址(甚至是1个)即可实现私有地址网络内所有计算机与Internet的通信需求。&lt;/li&gt;
&lt;li&gt;NAT将自动修改IP报文的源IP地址和目的IP地址，Ip地址校验则在NAT处理过程中自动完成（对于ICMP，NAT也自动完成地址转换）。有些应用程序将源IP地址嵌入到IP报文的数据部分中，所以还需要同时对报文进行修改，以匹配IP头中已经修改过的源IP地址。否则，在报文数据都分别嵌入IP地址的应用程序就不能正常工作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;工作原理&#34;&gt;工作原理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当一台内网计算机用户连接Internet资源时，该用户的 TCP/IP 协议产生一个 IP 数据包，该数据包包含以下值，这些值位于 IP 和 TCP 或 UDP 标头中：(粗体内容表示受 NAT 影响的项目)：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;目标 IP 地址：Internet 资源 IP 地址&lt;/li&gt;
&lt;li&gt;源 IP 地址：私有 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：Internet 资源 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：源应用程序 TCP 或 UDP 端口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请求源主机或者其它路由器将此 IP 数据包发送给 NAT, 然后由 NAT 将向外发送的数据包的地址解析如下：

&lt;ul&gt;
&lt;li&gt;目标IP地址：Internet 资源 IP 地址&lt;/li&gt;
&lt;li&gt;源IP 地址：ISP 分配的公用地址&lt;/li&gt;
&lt;li&gt;目标端口：Internet 资源 TCP 或 UDP 端口&lt;/li&gt;
&lt;li&gt;源端口：重新映射的源应用程序TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;NAT 将重新映射的 IP 数据包发送到 Internet 。响应计算机将向 NAT 返回一个响应。当 NAT 接收到此响应时，该数据包将包含以下地址信息：

&lt;ul&gt;
&lt;li&gt;目标IP 地址：ISP 分配的公用地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源IP地址：Internet 资源 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：重新映射的源应用程序 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：Internet 资源的 TCP 或者 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当 NAT 完成映射和解析地址后，将向 Internet 客户端发送数据包，此数据包包含以下地址信息：&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;目标 IP 地址：私有 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源 IP 地址：Internet 资源 IP 地址&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;目标端口：源应用程序TCP 或者 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;源端口：Internet 资源 TCP 或 UDP 端口&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;工作模式-三种-优缺点&#34;&gt;工作模式（三种，优缺点）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;NAT使用基于session的转换规则&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TCP/UDP&lt;/strong&gt; ：私有Host的Ipv4 + port &amp;lt;======&amp;gt; NAT公网的Ipv4 + port&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ICMP&lt;/strong&gt; ：私有Host的Ipv4 + sessionID &amp;lt;======&amp;gt; NAT公网的Ipv4 + sessionID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态NAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;静态NAT就是一对一映射，内部有多少私有地址需要和外部通信，就要配置多少外网IP地址与其对应，并不节省外网IP，所以一般不用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT1.png&#34; alt=&#34;静态NAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;动态NAT&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;动态NAT是在路由器上配置一个外网IP地址池，当内部有计算机需要和外部通信时，就从地址池里动态的取出一个外网IP，并将他们的对应关系绑定到NAT表中，通信结束后，这个外网IP才被释放，可供其他内部IP地址转换使用，这个DHCP租约IP有相似之处。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT2.png&#34; alt=&#34;动态NAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;PAT(port address Translation,端口地址转换,也叫端口地址复用)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这是最常用的NAT技术，也是IPv4能够维持到今天的最重要的原因之一，它提供了一种多对一的方式，对多个内网IP地址，边界路由可以给他们分配一个外网IP，利用这个外网IP的不同端口和外部进行通信。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;img src=&#34;https://luyuekai.github.io/content-img/NAT3.png&#34; alt=&#34;PAT&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>effective java 读书笔记（一）</title>
      <link>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</link>
      <pubDate>Sun, 16 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2017/04/effective-java-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;strong&gt;你是人间的四月天&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;
读书时有输入亦应该有输出,此篇记录阅读&lt;strong&gt;effective java&lt;/strong&gt;的重点及心得体会.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;第二章-创建和销毁对象&#34;&gt;第二章  创建和销毁对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一 . 考虑用静态工厂方法代替构造器&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类可以提供一个公有的静态工厂方法,它只是返回类的实例的静态方法.&lt;/p&gt;

&lt;p&gt;如下所示:来自Boolean(基本类型boolean的包装类)的简单示例.这个方法将boolean基本类型值转换成了一个Boolean对象引用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public static Boolean valueOf(boolean b){

return b ? Boolean.TRUE : Boolean.FALSE;

}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;- 优势

- 1. 静态工厂方法与构造器不同的第一大优势在与: 它们有名称.  

- 2. 第二大优势: 不必在每次调用它们的时候都创建一个新对象.

- 3. 第三大优势: 它们可以返回原返回类型的任何子类型的对象.

- 4. 第四大优势: 在创建参数化类型实例时,它们使代码变得更加简洁.  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二. 遇到多个构造器参数时要考虑用构建器&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在遇到许多构造器参数的时候,有第二种代替方法,即JavaBeans模式. 在这种模式下,调用一个无参构造器来创建对象,然后调用setter方法来设置每个必要的参数,以及每个相关的可选参数.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缺点: 在构造过程中JavaBean可能处于不一致的状态.类无法仅仅通过检验构造器参数的有效性来保证一致性.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;三. 用私有构造器或者枚举类型强化Singleton属性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;四. 通过私有构造器强化不可实例化的能力.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;五. 避免创建不必要的对象&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个极端的反面例子&lt;code&gt;String s = new String(&amp;quot;stringette&amp;quot;);&lt;/code&gt;该语句每次执行都会创建一个String实例,但是都是不必要的.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;改进版本: &lt;code&gt;String s = &amp;quot;stringette&amp;quot;&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;六. 消除过期的对象引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;七. 避免使用终结方法.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;终结方法的优先级要明显低于其他线程.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不应该依赖终结方法来更新重要的持久状态.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显式的终止方法通常与 try-finally 结构结合起来使用,以确保及时终止.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>位向量表示有限集合</title>
      <link>https://luyuekai.github.io/2016/04/%E4%BD%8D%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%9C%89%E9%99%90%E9%9B%86%E5%90%88/</link>
      <pubDate>Fri, 01 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://luyuekai.github.io/2016/04/%E4%BD%8D%E5%90%91%E9%87%8F%E8%A1%A8%E7%A4%BA%E6%9C%89%E9%99%90%E9%9B%86%E5%90%88/</guid>
      <description>&lt;p&gt;&lt;strong&gt;四月是你的谎言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;第二章-p33页&#34;&gt;第二章 P33页&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;由于无法显示公式,因此贴上本笔记的为知外连.供以后细看&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://3d1ff97e.wiz03.com/share/s/0Z7_B-0I14bu2BfsjO37ytJL2b-REp3s_QBd2c-O9v0f6UDE&#34;&gt;http://3d1ff97e.wiz03.com/share/s/0Z7_B-0I14bu2BfsjO37ytJL2b-REp3s_QBd2c-O9v0f6UDE&lt;/a&gt;&lt;br /&gt;
在阅读深入理解计算机系统该书时，发现了一个很好的idea， 通过位向量来表示有限集合。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;位向量&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;用位构成的向量，只有0,1组成。如[0,0,1,1,0,1,0]就是一个位向量。&lt;/li&gt;
&lt;li&gt;在用位向量表示集合时，我们规定右边代表最低位。&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们用位向量$\left {a&lt;em&gt;{w-1},a&lt;/em&gt;{w-2}&amp;hellip;a&lt;em&gt;{1},a&lt;/em&gt;{0}  \right }$编码任何子集$A\subseteq \left { 0,1,2&amp;hellip;,w-1 \right }$,其中$a&lt;em&gt;{i}=1$当且仅当$i\in A$,例如，（记住我们是将$a&lt;/em&gt;{w-1}$写在左边，而将$a_{0}$写在右边）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;位向量 $a\doteq \left { 01101001 \right }$表示集合A={0,3,5,6}。 解释： 对位向量a,从左至右，1的位置分别出现在第0,3,5,6的位置上，因此位向量a即表示了集合A；&lt;/li&gt;
&lt;li&gt;同理，$b\doteq \left{01010101 \right}$表示集合B={0,2,4,6}。 使用这种编码集合的方法，布尔运算| 和&amp;amp;分别对应于集合的并和交。而~则对应于集合的补。&lt;/li&gt;
&lt;li&gt;继续前面的例子， 运算 a&amp;amp;b得到位向量[01000001],而$A\bigcap B $={0,6}；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考：&lt;br /&gt;
&amp;lt; 1. 若是集合里面有相同的元素该怎么表示？&lt;br /&gt;
答： 集合有三大性质： &lt;code&gt;确定性&lt;/code&gt;,&lt;code&gt;无序性&lt;/code&gt;，&lt;code&gt;互异性&lt;/code&gt;.互异性决定了集合中无法有相同的元素。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>